import { Callout } from 'nextra-theme-docs'

# Markets and Outcomes

In the Azuro protocol, data on markets and outcomes cannot be accessed directly. Instead, the protocol employs
"conditions," which are objects that encompass multiple outcomes and the corresponding odds for each outcome. The odds
within a specific market will change when a user places a bet.

For instance, when a user bets on outcome "1" in the "Match Winner" market, the odds for both outcomes "1" and "2" will
be affected. Each condition is responsible for recalculating the odds accordingly.

To retrieve a list of markets and their associated outcomes, you must first obtain a list of conditions. Each condition
represents a distinct market and contains information about its corresponding outcomes.

You can acquire a list of conditions by sending GraphQL or RPC requests to the Core contract. After obtaining the
conditions list, iterate through it to extract the pertinent market and outcome information.

<Callout type="info" emoji="â„¹ï¸ï¸">
  It's important to clarify the meaning of certain terms used in the documentation to avoid any confusion.

  In this context, an "outcome" refers to an entity that contains information about a particular bet, including the market
  to which it belongs, game period, etc. To be clear each outcome contains a list of IDs:

  ```
  marketId
  gamePeriodId
  gameTypeId
  gameVarietyId
  pointsId
  selectionId
  teamPlayerId
  ```

  For further information on how to get and utilize these IDs, please refer to the relevant section in the documentation.
  [Read about outcome IDs and dictionaries](/build-own-app/reference/dictionaries).
</Callout>


## Aggregate outcomes by markets

If try to explain in simple words the process of combining outcomes by markets, then this is a search for such outcomes
whose `marketId`s match. But there is a nuance - `marketId` doesn't represent the pointer to the market ðŸ¤”. The world
of betting is not so simple, yes.

To obtain the correct pointer to a market, it is necessary to combine multiple IDs to create a unique `marketKey`.
In Azuro, we use a specific format for creating a `marketKey`, which is

```js
marketId-gamePeriodId-gameTypeId[-teamPlayerId]
```

It is important to note that the `teamPlayerId` is optional, as not all outcomes have it.

To generate the unique `marketKey` identifier, you can use the `getMarketKey` helper function from
the [`@azuro-org/dictionaries`](https://www.npmjs.com/package/@azuro-org/dictionaries) package.

In the following example, we will iterate through a list of game conditions and results with an array of markets.
Each market will have its own name and a list of outcomes associated with it.

```graphql
query Game($id: String!) {
  game(id: $id) {
    liquidityPool {
      address
    }
    conditions {
      conditionId
      coreAddress
      outcomes {
        outcomeId
      }
    }
  }
}
```

```ts
import { getMarketKey, getMarketName, getSelectionName } from '@azuro-org/dictionaries'
import dictionaries from '@/dictionaries'

// the final outcome object can contain any field that is relevant to your application. Extend the query with additional
// fields if required. However, there are certain fields that are required as parameters for placing bets
type Outcome = {
  conditionId: string
  outcomeId: string
  lpAddress: string
  coreAddress: string
  selectionName: string
}

// the result we are aiming to obtain is a list of markets, which will be of type Market[]
type Market = {
  marketName: string
  outcomes: Outcome[]
}

const lpAddress = game.liquidityPool.address
const marketsMap: Record<string, Market> = {}

conditions.forEach(({ conditionId, outcomes, coreAddress }) => {
  outcomes.forEach(({ outcomeId }) => {
    // we are using the same key format that was discussed earlier
    const marketKey = getMarketKey(outcomeId, dictionaries)

    // we are obtaining the human-readable names of each market and the corresponding outcome selections
    const marketName = getMarketName(outcomeId, dictionaries)
    const selectionName = getSelectionName(outcomeId, dictionaries)

    const outcome: Outcome = {
      conditionId,
      outcomeId,
      lpAddress,
      coreAddress,
      selectionName,
    }

    if (!marketsMap[marketKey]) {
      marketsMap[marketKey] = {
        marketName,
        outcomes: [],
      }
    }

    marketsMap[marketKey].outcomes.push(outcome)
  })
})
```

At this point, we have successfully combined outcomes into groups that share the same market key.

To improve the UX, it's recommended to group the available outcomes within each market and sort them in a meaningful way.
To better illustrate the concept of grouping and sorting outcomes within a market, let's use Handicap as an example.

<Callout type="info" emoji="â„¹ï¸ï¸">
  Handicap - this is a bet where an artificial advantage is given to one of the teams. E.g. if 'Team 1' has Handicap +1, it means
  that the final result of the game is determined after adding 1 goal to the number of goals scored by 'Team 1'.
</Callout>


```ts
type FinalMarket = {
  name: string
  outcomes: Outcome[][]
}

const finalMarketsMap: Record<string, FinalMarket> = {}

// sort by outcomeId and group by conditionId
Object.keys(marketsMap).forEach((marketKey) => {
  const { marketName, outcomes } = marketsMap[marketKey]

  finalMarketsMap[marketKey] = {
    marketName,
    outcomes: null,
  }

  // sort the outcomes by `selectionId` (outcome's selection reference)
  outcomes.sort((a, b) => {
    const left = dictionaries.outcomes[a.outcomeId].selectionId
    const right = dictionaries.outcomes[b.outcomeId].selectionId

    return left - right
  })

  // "Full Time Result" and "Double Chance" are the markets whose outcomes don't require sorting
  const MARKETS_THAT_DONT_NEED_GROUPING = [ 1, 2 ]
  const marketId = marketKey.split('-')[0]

  if (MARKETS_THAT_DONT_NEED_GROUPING.includes(+marketId)) {
    // it's worth noting that the outcomes are wrapped within an array here due to the "rows" that are presented below
    finalMarketsMap[marketKey].outcomes = [ outcomes ]
  }
  else {
    // group the outcomes by condition ID, which will allow us to display the draw outcomes in separate rows
    //
    // Handicap:
    // H1 (-0.5)  H2 (0.5)
    // H1 (0.5)   H2 (-0.5)
    const outcomesByConditionId: Record<string, Outcome[]> = {}

    outcomes.forEach((outcome) => {
      const key = outcome.conditionId

      if (!outcomesByConditionId[key]) {
        outcomesByConditionId[key] = []
      }

      outcomesByConditionId[key].push(outcome)
    })

    const rows: Outcome[][] = Object.values(outcomesByConditionId)

    finalMarketsMap[marketKey].outcomes = rows.sort((a, b) => {
      const aSum = a.reduce((acc, { outcomeId }) => acc + +outcomeId, 0)
      const bSum = b.reduce((acc, { outcomeId }) => acc + +outcomeId, 0)

      return aSum - bSum
    })
  }
})

const finalMarkets = Object.values(finalMarketsMap)
```

The example provided demonstrates how you can group and sort outcomes. However, it is important to note that the sorting
method may differ depending on the specific requirements of your application.

If the grouping and sorting method described above is suitable for your needs, you can utilize the
`aggregateOutcomesByMarkets` helper function from the [`@azuro-org/toolkit`](https://www.npmjs.com/package/@azuro-org/toolkit) library.
This function can assist with grouping and sorting outcomes by market key.

## Try it yourself

[Playground](https://stackblitz.com/edit/react-ts-3ggqdj?file=useData.ts)
